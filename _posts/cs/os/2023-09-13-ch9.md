---
title: "[운영 체제와 정보기술의 원리] 9장. 디스크 관리"
categories: [CS, OS]
math: true
---


## Intro

Memory는 **volatile**(휘발성)이기 때문에 데이터를 영구히 보관하기 위해서는 <span class="hl">disk</span>와 같은 2차 저장장치가 필요하다.

이 포스트에서는 disk의 효율적인 관리를 위해 사용되는 <span class="hl">disk scheduling 기법</span>과 <span class="hl">저전력 disk 관리 기법</span>에 대해 알아본다.

## 1. Disk의 구조

<span class="hl">Logical block</span> (논리블록)
* Disk 외부에서는, disk를 일정한 크기의 저장공간들로 이루어진 **1차원 배열**로 취급한다. 이러한 저장공간 unit을 **logical block**이라고 한다.
* Disk에 데이터가 **저장 및 입출력**이 될때에도 logical block단위로 저장/전송된다.
* Logical block에 저장된 데이터에 접근하려면 배열처럼 **index number**을 disk에 전달해야 한다. 그러면 disk controller가 해당 logical block이 저장된 물리적 위치를 찾아 I/O 작업을 수행한다.
* <span class="hl">Sector</span>
  * 각 logical block이 저장되는 disk내의 물리적인 위치를 **sector(섹터)**라고 부른다.
  * 즉, **logical 하나가 sector 하나랑 1:1 매핑된다**.


![Alt text](/assets/img/os/os9_1.png)

* Disk는 하나/여러개의 <span class="hl">마크네틱 원판</span>으로 구성된다
* 각각의 원판은 여러개의 <span class="hl">track (트랙)</span>으로 나뉜다
* 각 트랙은 여러개의 <span class="hl">sector</span>(최소단위) 으로 나뉜다
* 여러개의 원판에서 상대적 위치가 동일한 track들의 집합을 <span class="hl">cylinder</span>라고 한다.
* ex) Sector 0: outermost cylinder, 1st track, 1st sector이다.
* 데이터를 read/write하기 위해서는 <span class="hl">arm</span>이 해당 sector가 위치한 cylinder으로 이동한후, 원판이 rotate하여 <span class="hl">disk head</span>가 sector 위치에 도달한다.

## 2. Disk Scheduling

Disk에 대한 access time (접근 시간)은 어떻게 구할까?

* <span class="hl">Disk access time</span>의 3가지 종류
  * <span class="hl">Seek Time</span> (탐색시간)
    * Disk head를 해당 cylinder 위치로 이동시키는 시간 (데이터가 원판 안쪽/바깥쪽에 있는지에 따라 헤드를 움직이는 시간)
  * <span class="hl">Rotational Latency</span> (회전지연시간)
    * Disk가 회전해서 데이터가 head 위치에 도달하는데 걸리는 시간
  * <span class="hl">Transfer Time</span> (전송시간)
    * Sector이 head 위치에 도달한후, 데이터를 실제로 읽고 쓰는데 소요되는 시간

Disk의 입출력 효율을 높이기 위해서는 disk access time을 줄여야 한다.

Access time을 줄이기 위해서는 seek time, rotational latency, transfer time을 줄여야 하는데, 

**Rotational latency**와 **transfer time**은 수치가 작을 뿐 아니라 통제하기 힘들어서 무시한다.

결국 **seek time을 최소화하는 disk scheduling**을 한다.

<span class="hl">Disk Scheduling</span>
* 효율적인 Disk I/O를 위해, 여러 sector들에 대한 I/O 요청이 들어왔을때, 이들을 **어떠한 순서**로 처리할 것인지 결정하는 메커니즘.

> Disk scheduling의 가장 중요한 목표는 **seek time**을 줄이는것, 즉 **disk head의 이동거리를 최소화 하는것**이다.
{: .prompt-info}

### 1) FCFS Scheduling

FCFS(First Come First Server) 스케쥴링은 disk에 먼저 들어온 요청을 먼저 처리하는 방식이다.

예를 들어, 다음과 같은 **cylinder 위치**에 입출력 요청이 들어왔다고 하자 (disk에 총 200개 cylinder이라고 가정)

`99 184 36 123 15 125 66 68`

만약 disk head가 처음에 54번 cylinder에 있을 경우에 head는

* 54 -> 99
* 99 -> 184
* ...

와 같이 이동하게 된다. 따라서 총 이동거리를 계산하면 `644`가 된다.

**FCFS은 효율성이 매우 떨어진다.**
* I/O 요청이 만약 계속 현재 head 위치보다 먼 곳에 위치하면 seek time이 매우 늘어난다
* 극단적으로 disk의 한쪽 끝과 다른 한쪽 끝에서 반복적으로 요청이 들어오면 최악의 경우가 된다.

### SSTF(Shortest Seek Time First) Scheduling

SSTF 스케쥴링은 <span class="hl">head의 현재 위치로부터 가장 가까운 위치에 있는 요청을 먼저 처리</span>하는 방식이다.

만약 `99, 184, 36, 123, 15, 125, 66, 68` cylinder 위치에 요청들이 들어왔고, head의 위치가 현재 `54`이라면,

* 54에서 제일 가까운 `66`으로 이동
* `66` -> `68`
* ...

그러면 총 이동거리는 `236`이 된다.

**SSTF의 한계**
* FCFS보단 낫지만 <span class="hl">starvation</span>현상이 발생할 수 있다
  * 현재의 head위치에서 가까운곳에서 지속적으로 요청이 들어온다면, head로부터 먼곳의 애들은 무한히 기다려야 할수도 있다.


### SCAN Algorithm

![Alt text](/assets/img/os/os9_2.png)
SCAN 알고리즘은 head가 disk 원판 안쪽 끝과 바깥쪽 끝을 왕복하며, 그 경로에 존재하는 모든 요청을 처리한다.
* 즉, disk 요청에 상관없이, head는 정해진 방향으로 이동하면서 길목에 있는 녀석들을 다 처리하는것이다.

SCAN 알고리즘은, 엘리베이터에서 사용하는 스케줄링 알고리즘과 유사하다. 엘리베이터는 한 방향으로 이동하면서 진행 방향으로 가는 승객에 있으면 다 태운다. 그리고 그 방향으로 요청이 없으면 방향을 바꾸어서 반복한다.

따라서, SCAN 알고리즘은 <span class="hl">elevator algorithm</span>이라고 불리기도 한다.

![Alt text](/assets/img/os/os9_3.png)

#### SCAN 알고리즘의 장/단점
* **장점**: SCAN 알고리즘에서는, FCFS처럼 불필요한 head의 움직임이 발생하거나, starvation현상이 발생하지 않기에, **효율성**과 **형평성**을 모두 만족한다.
* **단점**: 하지만, 모든 cylinder 위치의 기다리는 시간이 공평한 것은 아니다. 제일 안쪽이나 제일 바깥쪽 보다는 가운데 위치가 기다리는 평균시간이 더 짧다.
  * 0 ~ 199번 cylinder가 있다고 할때, 헤드가 가장자리인 0번 혹은 199번 실린더를 지금 막 지나가고 나서, 해당 지점에 요청에 들어온다면 헤드의 이동거리가 400이 지나고 난 후에야 서비스가 가능하다.
* 이 문제를 보환하기 보완하기 위해 **C-SCAN Algorithm**이 제안되었다.

## C-SCAN Algorithm
![Alt text](/assets/img/os/os9_4.png)
<span class="hl">C-SCAN Algorithm</span> (Circular-SCAN)은 SCAN처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 요청을 다 처리한다는 점은 동일하다.

다른 점은, 헤드가 한 쪽 끝에 도달해 **다른 쪽으로 돌아갈때, 요청을 처리하지 않고 곧바로 출발점으로 이동한다**.
* 이 방식은, head의 이동거리는 조금 더 길어지지만, **탐색시간의 편차를 줄일 수 있다**.

![Alt text](/assets/img/os/os9_5.png)

## LOOK과 C-LOOK 알고리즘

### LOOK 알고리즘
SCAN 알고리즘에서는, 요청의 존재 여부와 상관없이 헤드가 무조건 disk의 한쪽 끝에서 다른 쪽 끝으로 이동한다.

반면 <span class="hl">LOOK</span> 알고리즘은 head가 한쪽 방향으로 이동하지만, **그 방향에 더이상 요청이 없으면 방향을 반대로 바꾼다.**

### C-LOOK 알고리즘

![Alt text](/assets/img/os/os9_6.png)

전방에 요청이 없을때 방향을 바꾸는건 LOOK이랑 유사하지만, 한쪽 방향으로 이동할 때에만 요청을 처리한다는 점에서는 C-SCAN과 유사하다.
* 위의 그림에서 head가 184번 cylinder에서 더 이상의 요청이 없으므로 199번 까지 가지않고 즉시 방향을 바꾼다.
* 또한 head가 반드시 0번까지 가는것이 아니라 요청이 존재하는 가장 낮은 cylinder 번호까지만 간다.
