---
title: "[운영 체제와 정보기술의 원리] 8장. 가상메모리"
categories: [CS, OS]
math: true
---

## 0. Virtual Memory

프로그램이 실행되려면 실행에 "당장" 필요한 부분이 memory에 적재되어 있어야 한다.

현대 time-sharing 시스템에서는 여러개의 process들이 메모리를 함께 사용하므로, OS는 "**어떤 process에게 어느정도의 memory를 할당할지**"를 결정해야 한다.

OS는 보통 하나의 process에 메모리를 몰빵해서 주기보다는 몇몇 process들에게 집중적으로 할당하고, 시간이 흐르면 이들로부터 메모리를 회수해서 또 다른 process들에게 주는 방식으로 동작한다.
* Process의 빠른 실행을 위해 process마다 "최소한" 확보해야하는 memory의 크기가 존재하기 떄문이다.

프로그램이 실행되기 위해 그 process의 address space의 전체가 메모리에 적재되어야 있어야 되는것은 아니다. **OS는 당장 필요한 부분만을 메모리에 적재**하고, 그렇지 않은 부분은 disk의 <span class="hl">swap area</span>에 내려놓고, 다시 필요하면 메모리에 있는 부분들과 교체한다.
* 이런 방식을 채택함으로써 프로그램 입장에서 "**physical memory의 크기에 대한 제약**"에서 자유로워진다.
* 또한, 프로그램 입장에서 physical memory를 생각할 필요 없이 자기 자신만의 독자적인 memory를 사용하는것을 가정할 수 있는데, 이러한 공간을 <span class="hl">virtual memory</span>이라고 부른다.
  * 즉, virtual memory는 process 각각 마다 `0`부터 시작하는 address space를 가지게 된다. 이들 중 일부는 메모리에 적재되고, 나머지는 swap area에 존재한다.

### Virtual Memory 기법

1. <span class="hl">Demand Paging</span> (요구 페이징)
   * 대부분의 경우에 이 방식을 사용한다.
2. <span class="hl">Demand Segmentation</span> (요구 세그먼테이션)
   * 하나의 segment를 여러개의 page로 나누는 **paged segmentation** 방법에서 사용한다.
   * 즉, 세부적인 구현에서는 demand paging만 사용된다고 할 수 있다.


## 2. Demand Paging (요구 페이징)

> <span class="hl">Demand Paging</span>: 프로그램 실행 시, process를 구성하는 모든 page를 한꺼번에 메모리에 올리는게 아니라, **당장 사용될 page만을 올리는 방식**을 말한다.
{: .prompt-info}

* Demand paging에서는 **특정 page에 대해 CPU의 요청이 들어온 후에야, 해당 page를 메모리에 적재**한다.
* 이런 기법의 장점
  1. **Memory 사용량이 감소**한다 (필요한 부분만 적재하기 때문)
  2. **I/O overhead가 줄어든다** (process 전체를 메모리에 올리는데 소요되는 I/O overhead 줄어든다)
  3. **Response time이 단축**된다 (사용되지 않을 주소 영역에 대한 I/O 불필요)
  4. 시스템에 **더 많은 process를 수용**할 수 있다.
  5. 프로그램이 physical **memory의 용량 제약에서 벗어난다** (일부 page만을 적재하여 physical memory보다 큰 프로그램도 실행가능)

Virtual memory기법에서는 process가 실행되는 동안 일부 page만 메모리에 있고 나머지는 swap area에 있다. 이런 시스템 특성상, 특정 process의 페이지들중에서 "어떤 page가 메모리에 존재하고, 어떤 page가 메모리에 존재하지 않는지"를 구별하기 위해서 <span class="hl">valid-invaild bit</span> (유효-무효 비트)를 표시한다.
* process의 모든 page에 대해 존재하므로, page table의 각 entry에 저장된다.
* Process가 실행되기 전에는 `invalid`로 초기화되고, 특정 page가 참조되어 memory에 적재되면 `valid`로 바뀐다.
* Memory -> Swap area로 쫓겨날때는 다시 `invalid`가 된다.
* `Invalid`인 경우
  1. Page가 현재 memory에 없는 경우
  2. 그 page가 속한 address space를 process가 사용하지 않는 경우
* <span class="hl">Page fault</span> (페이지 부재)
  * CPU가 참조하려는 page가 현재 memory에 올라와있지 않아, `invalid` bit로 세팅되어 있는 경우

### Demand Paging의 page fault 처리

CPU가 invalid page에 접근하면
1. Address translation을 담당하는 하드웨어인 **MMU**가 <span class="hl">page fault trap</span>을 발생시킨다.
2. CPU 제어권이 **kernel mode**로 바뀌고, OS의 <span class="hl">page fault handler</span> (페이지 부재 처리루틴)이 호출되어 다음 그림과 같이 처리한다

![Alt text](/assets/img/os/os-ch8-1.png)
* Page fault 처리 과정
  1. CPU가 page N을 참조한다
  2. Page table에서 page N이 invalid 상태를 확인한다
  3. Page fault trap이 발생한다
  4. Disk에서 부재 page를 empty frame으로 적재하고, page table을 업데이트한다.

즉, 부재 상태의 page를 memory에 적재하기에 앞서 OS는 해당 **page에 대한 접근이 적법한지를 체크**한다.

다음 두 경우에 해당하면 process를 종료시킨다.
* 사용되지 않는 address space에 속한 page에 접근
* 해당 page에 대한 접근 권한 위반 (**protection violation**)
  * Read-only인 page에 write 시도한 경우

해당 page에 대한 접근이 적법하다고 판명이 나면,
1. Physical memory에서 **free frame**을 할당받아, 그 공간에 해당 page를 읽어온다
2. 만약 free frame이 없다면, 기존의 메모리에 있는 페이지 중 하나를 swap area로 쫓아낸다 (**swap out**)

> 한편, 요청된 page를 **disk -> memory로 적재**하기까지는 **오랜 시간이 소요**된다
>
> Page fault를 발생시킨 process는 CPU를 빼앗기고 **blocked state**가 되며, 현재까지 수행하던 register 및 PC 값등을 **PCB**에 저장한다. Disk I/O가 완료되어 interrupt가 발생하면 page table에서 해당 page의 **valid-invalid bit**를 valid로 세팅하고 다시 process를 blocked state에서 **ready queue**로 이동시킨다. 그러면 PCB에 저장되어 있던 context를 복원시켜 이전에 중단되었던 명령을 재개한다.
{: .prompt-tip}

### Demand Paging의 성능

Demand paging의 성능에 가장 큰 영향을 미치는것은 <span class="hl">page fault의 발생 빈도</span>이다.
* Page fault가 일어나면 요청된 page를 **Disk -> Memory**로 읽어오는 막대한 overhead 발생.

* Effective Access Time (유효 접근시간)

    ```
    (1 - P) * memory access time
    + P * (
    page fault 처리 overhead +
    메모리에 empty frame이 없는 경우 swap-out overhead +
    요청된 page의 swap-in overhead +
    process 재시작 overhead
    )
    ```
    * `p`: page fault rate [0, 1]

Page fault가 일어나면 다음과 같은 overhead가 발생한다
1. Memory에 올라와 있는 page 중 하나를 swap out시킨 후, 요청된 page를 memory로 swap-in 시킨다.
2. 다 읽어왔으면 interrupt를 통해 프로세스를 ready-queue에 넣어준다

이러한 과정에는 disk I/O와 각종 overhead가 일어나서 시간이 오래걸린다. 따라서, effective access time이 줄어들수록 demand paging의 성능은 향상된다.